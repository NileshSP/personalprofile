import { timestamp, files, shell, routes } from '@sapper/service-worker';
/* eslint-disable no-undef */
/* eslint-disable no-restricted-globals */
importScripts('https://storage.googleapis.com/workbox-cdn/releases/4.1.1/workbox-sw.js');

const ASSETS = `NileshProfile${timestamp}`;

// `shell` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory
const to_cache = shell.concat(files);

self.addEventListener('install', event => {
	event.waitUntil(
		caches
			.open(ASSETS)
			.then(cache => cache.addAll(to_cache))
			.then(() => self.skipWaiting())
	);
});

self.addEventListener('activate', event => {
	event.waitUntil(
		caches.keys().then(async keys => {
			// delete old caches
			for (const key of keys) {
				if (key !== ASSETS) await caches.delete(key);
			}

			self.clients.claim();
		})
	);
});


const { strategies, backgroundSync, cacheableResponse } = workbox;

const bgSyncPlugin = new backgroundSync.Plugin('NileshProfileFetchQueue', {
  maxRetentionTime: 24 * 60 // Retry for max of 24 Hours
});

const strategyToApply = new strategies.StaleWhileRevalidate({
  cacheName: ASSETS,
  plugins:[
    bgSyncPlugin,
    new cacheableResponse.Plugin({
      statuses: [0,200]
    })
  ]
});

// workbox.core.skipWaiting();
// workbox.core.clientsClaim();

const graphqlUpdateCache = async (event, cachesName) => {
	console.log(`graphqlUpdateCache started`)
	const currReq = await event.request.clone();
	const currReqBody = await currReq.text();
	const regExMatch = /getRequest\w+/gi.exec(currReqBody);
	const cacheName = regExMatch[0] ? regExMatch[0] : null;
	console.log(`graphqlUpdateCache cachename`, cacheName)
	return caches.open(cachesName).then((cache) => {
		console.log(`graphqlUpdateCache ${cachesName} opened`)
		return fetch(event.request)
						.then((response) => {
							console.log(`graphqlUpdateCache fetch response received`)
							if (cacheName) {
								return cache.put(cacheName, response.clone()).then(() => {
									console.log(`graphqlUpdateCache cache ${cacheName} updated and response is returned`)
									return response;
								});
							}
							else {
								console.log(`graphqlUpdateCache cache ${cacheName} is not updated and response is returned`)
								return response;
							}
						})
						.catch(async err => {
							console.log(`graphqlUpdateCache fetch error`, err)								
							return await graphqlFromCache(event, cachesName, cacheName)
						});
	});
}

const graphqlFromCache = async (event, cachesName, cacheName) => {
	console.log(`graphqlFromCache started with cachename`, cacheName)
	if(cacheName) {
		return caches.open(cachesName).then(async (cache) => {
			console.log(`graphqlFromCache finding ${cacheName} in ${cachesName}`)
			const reqCache = await cache.match(cacheName);
			console.log(`graphqlFromCache cache found as,`, reqCache)
			return reqCache || new Response(new Blob(), {status: 404, statusText: "not found in cache"}) ;
		});
	}
	else {
		console.log(`graphqlFromCache cache with name as ${cacheName} not found in ${cachesName}`)
	}
}

const refreshClient = (response) => {
  return self.clients.matchAll().then((clients) => {
    clients.forEach((client) => {
      var message = {
        type: 'refresh',
        url: response.url,
        eTag: response.headers.get('ETag')
      };
      client.postMessage(JSON.stringify(message));
			self.clients.claim();
    });
  });
}

workbox.routing.registerRoute(
  ({ url, event }) => /graphql\b/gi.exec(url),
  async ({url, event, params}) => {
		console.log(`router for graphql is being processed with respondWith`)
		event.respondWith(graphqlUpdateCache(event, ASSETS));
		// event.waitUntil(graphqlUpdateCache(event, ASSETS).then(refreshClient));
	},
	'POST'
);

workbox.routing.registerRoute(
	({ url, event }) => /^http/gi.exec(url) && !/graphql\b/gi.exec(url),
	// new RegExp(`${publicUrl}`,'i'),
  strategyToApply
);


self.addEventListener('fetch', (event) => {
	console.log(`addEventListener:fetch - with strategyToApply `)
	return event.waitUntil(strategyToApply.makeRequest({request: event.request}));
});