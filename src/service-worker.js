import { timestamp, files, shell, routes } from '@sapper/service-worker';
/* eslint-disable no-undef */
/* eslint-disable no-restricted-globals */
importScripts('https://storage.googleapis.com/workbox-cdn/releases/4.3.1/workbox-sw.js');

const ASSETS = `NileshProfile${timestamp}`;

// `shell` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory
const to_cache = shell.concat(files);

self.addEventListener('install', event => {
	event.waitUntil(
		caches
			.open(ASSETS)
			.then(cache => cache.addAll(to_cache))
			.then(() => self.skipWaiting())
	);
});

self.addEventListener('activate', event => {
	event.waitUntil(
		caches.keys().then(async keys => {
			// delete old caches
			for (const key of keys) {
				if (key !== ASSETS) await caches.delete(key);
			}

			self.clients.claim();
		})
	);
});

if(workbox) {
	const { strategies, backgroundSync, cacheableResponse } = workbox;
	
	const bgSyncPlugin = new backgroundSync.Plugin('NileshProfileFetchQueue', {
		maxRetentionTime: 24 * 60 // Retry for max of 24 Hours
	});

	const strategyToApply = new strategies.StaleWhileRevalidate({
		cacheName: ASSETS,
		plugins:[
			bgSyncPlugin,
			new cacheableResponse.Plugin({
				statuses: [0,200]
			})
		]
	});

	const graphqlUpdateCache = async (event, cachesName) => {
		const currReq = await event.request.clone();
		const currReqBody = await currReq.text();
		const regExMatch = /getRequest\w+/gi.exec(currReqBody);
		const cacheName = regExMatch.length > 0 ? regExMatch[0] : null;
		return caches.open(cachesName).then(async (cache) => {
			try {			
				return await fetch(event.request)
								.then((response) => {
									if (cacheName) {
										return cache.put(cacheName, response.clone()).then(() => {
											return response;
										});
									}
									else {
										return response;
									}
								})
		} catch (error) {					
				return await graphqlFromCache(event, cachesName, cacheName)
			}
		});
	}

	const graphqlFromCache = async (event, cachesName, cacheName) => {
		if(cacheName) {
			return caches.open(cachesName).then(async (cache) => {
				const reqCache = await cache.match(cacheName);
				return reqCache || new Response(new Blob(), {status: 404, statusText: "not found in cache"}) ;
			});
		}
		else {
			console.log(`graphqlFromCache cache with name as ${cacheName} not found in ${cachesName}`)
		}
	}

	const refreshClient = (response) => {
		return self.clients.matchAll().then((clients) => {
			clients.forEach((client) => {
				var message = {
					type: 'refresh',
					url: response.url,
					eTag: response.headers.get('ETag')
				};
				client.postMessage(JSON.stringify(message));
				self.clients.claim();
			});
		});
	}

	const isGraphQlRequest = (url) => /graphql\b/gi.exec(url);

	workbox.routing.registerRoute(
		({ url, event }) => isGraphQlRequest(url),
		async ({url, event, params}) => {
			event.respondWith(graphqlUpdateCache(event, ASSETS));
		},
		'POST'
		);
		
		workbox.routing.registerRoute(
			({ url, event }) => /^http/gi.exec(url) && !isGraphQlRequest(url),
		strategyToApply
	);


	self.addEventListener('fetch', (event) => {
		return event.waitUntil(strategyToApply.makeRequest({request: event.request}));
	});
}